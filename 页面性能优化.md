## 对症下药

自学前端以来，“如何进行页面性能优化”，“怎样使页面加载速度更快”……类似的文案看过听过不少。同时解决这类问题的方案也不少，譬如使用**雪碧图，图片based64，cdn，css/js合并，css/js/图片压缩，缓存，图片懒加载**等等。至于为什么这样做可以加快页面加载速度，我一直不太清楚，这也让我一度苦恼。好吧，我就随便哔哔几句，下面正式开始说页面性能优化的问题，如有错误欢迎指正。

解决一个问题前，肯定得先明白导致这个问题的原因是什么？

首先，我们需要了解，在浏览器中输入一个url至页面呈现在用户面前 这一过程到底发生了什么？这个过程在这就不阐述，需要了解的同学请点击[这里](https://www.jianshu.com/p/c1dfc6caa520)。

在整个过程中仅有10%~20%的时间耗费在***DNS域名解析至接收响应结果(即html文档)***这一过程中，80%~90%的时间耗费在解析html请求下载相关资源上面。

![](https://github.com/shaniawei/resource/blob/master/images/7.jpg)

由此图可以看出，每请求下载一个资源都需要耗费一定的时间，所以这是不是意味着如果一个网页需要请求下载的资源越少那么整个过程耗费的时间就越短呢？同时如果请求下载某个资源所需的时间越少是不是也意味着整个过程耗费的时间越短呢？既如此，怎样加快页面加载速度的大方向就确定了。

### **第一，减少请求下载资源的数量，即减少http请求数：**

一个页面的相关资源大致分为html、图片、css、js、media、websocket、font等，大部分页面加载图片、js、css较多，可从以下几个方面减少http请求数。

1. #### **图片**

- ##### ***图片地图(图片热区map area)***

    图片地图适用于网页的导航条部分(图片元素)。有时候网页的导航条部分使用的是视觉感受更好的图片元素而不是单纯的文字，点击不同的图片进入到对应的页面。假设某个网页的导航条有四个部分，那么对应的就有四张图片，既如此就会产生4个http请求。

    使用图片地图的方式，可以把这四张图拼成一张图，利用area标签设置图片的热点区域进行相应的跳转。这样的话，http请求数从4个变成1个。

    `图片地图的优点`

  > 减小图片总和的字节数
  >
  > 减少http请求数

  `图片地图的缺点`

  > coords坐标值需要精确，手工测量容易造成误差
  >
  > 不能作为背景写入css中
  >
  > 不支持响应式，coords坐标只能编辑固定的px值


```html

<img src="planets.jpg" border="0" usemap="#planetmap" alt="Planets" />

<map name="planetmap" id="planetmap">

  <area shape="circle" coords="180,139,14" href ="venus.html" alt="Venus" />

  <area shape="circle" coords="129,161,10" href ="mercur.html" alt="Mercury" />

  <area shape="rect" coords="0,0,110,260" href ="sun.html" alt="Sun" />

</map>
```

- ##### **雪碧图**

    [可使用gulp-css-spriter生成雪碧图](https://www.cnblogs.com/alone2015/p/5328079.html)

    一个网页中总会有一些小图标icon。将这些icon整理在一张图片上，也可以将许多个http请求折中成一个http请求。利用background-image,background-position,background-repeat组合显示想要的icon。

    ![](https://github.com/shaniawei/resource/blob/master/images/8.jpg)

    `雪碧图的优点`

  > 减少了http请求数
  >
  > 减少了图片总和的字节数(虽然增加了许多空白的区域，但是旨在减少图片本身的开销：颜色表、格式信息……)
  >
  > 便于更换网站风格，更换一张或少张图片的样式/颜色，即可更换整个网站的风格
  >
  > 解决了开发命名困扰，只需给一张或少张图片命名即可

  `雪碧图的缺点`

  > 必须精确的知道某个icon的坐标位置
  >
  > 拼图维护较为麻烦


-   ##### **图片based64**

    满足以下4个条件适用于使用图片based64：

    这类图片不能与其他图片以CSS Sprite的形式存在，只能独行

    这类图片从诞生之日起，基本上很少被更新

    这类图片的实际尺寸很小

    这类图片在网站中大规模使用

    `图片based64的优点`


    > 不需要http请求资源
    >
    > 某些文件可以避免跨域的问题？
    > 在频繁更新的html文件中不存在清理缓存的问题

    `图片based64的缺点`

    > IE6/7浏览器不支持
    > 迫使html/css文件变大
    > 只能在外联css中作为背景图才能缓存


- **字体图标**

  `字体图标的优点`

  > 减少http请求
  >
  > 字体图标大小比位图稍小些
  >
  > 可通过css设置文字效果，包括大小、颜色、Hover状态、透明度、阴影和翻转等效果

  `字体图标的缺点`

  > 图标字体只能被渲染成单色或者CSS3的渐变色




2.**CSS、JS文件**

- 一个网页的外联css文件数尽量控制在2个以内
- 小于2kb的css/js文件使用内联方式内嵌在html文档中
- 生成环境下，可进行合并的js/css文件都合并，减少css/js文件数  [合并方法-查看gulp-concat插件](https://github.com/shaniawei/resource/blob/master/%E9%9A%8F%E7%AC%94%2B%E8%AE%B0%E5%BD%95/gulp.md)




### **第二，加快请求下载资源的速度**

首先通过查看Chrome开发工具的network面板中的**资源时间轴**可以清楚地了解请求某个资源完整的耗时信息。

**`打开资源时间轴的方式：`**

1. 将鼠标悬停到 Timeline 列下的耗时图表上。这将呈现一个显示完整耗时数据的弹出窗口。

   ![](https://github.com/shaniawei/resource/blob/master/images/time2.png)

2. 点击任何条目并打开该条目的 Timing 标签。

   ![](https://github.com/shaniawei/resource/blob/master/images/time.png)



> 了解下timeline里面这几个字段的意思。[点击这里](https://www.cnblogs.com/zhenwen/p/5827925.html)，[官网解说(需翻墙)](https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing)

- Content Download / Downloading ——接收响应数据所用的时间。

  数据内容越多，所需传输时间也就越多。但是为了满足业务需求又没法删除。可从以下几个方面进行优化：

  - [x] html、css、js文件 删除注释和无用的代码

  - [x] html、css、js文件 代码规范，注重代码的复用

  - [x] 服务器端使用gzip压缩

        > 优化页面性能从服务器端的角度来说，在服务器端做压缩配置，将浏览器请求的页面以及页面中的静态资源以压缩包的形式发送给客户端，大大减小了文件体积大小，减少下载时间。
        >
        > 压缩css、js，可以在前端已经压缩的基础上再减小40%左右。至于图片文件、(pdf/音乐文件？)这类本身已经是高度压缩格式，重复压缩的作用不大，反而会增加cpu的处理时间以及浏览器解压渲染时间。

  - [x] 前端压缩css/js文件/图片

        > 压缩js/css： [压缩方法-查看gulp-uglify/gulp-minify-css](https://github.com/shaniawei/resource/blob/master/%E9%9A%8F%E7%AC%94%2B%E8%AE%B0%E5%BD%95/gulp.md)
        >
        > 压缩图片：[使用无损压缩工具](https://www.zhihu.com/question/19779256)

- Waiting (TTFB)——从请求发送到达服务器开始计时，直至数据第一个字节返回给到客户端结束计时。会受到线路、服务器距离、后台数据查询等因素的影响。

  - [x] 使用cdn

        > cdn就是在网络的各处放置节点服务器所构成的一组只能虚拟网络服务器组，这个系统实时根据网络流量和各个节点的连接、负载状况以及用户的距离等综合信息将用户的请求重新导向离用户最近的服务节点上，拉近用户位置与资源服务器位置之间的距离，**减轻服务器负载**。
        >
        > ​
        >
        > 浏览器缓存是根据不同的域进行缓存的，也就是说如果不同的域引用了同一个资源，这个资源会被缓存两次。这就很占用本地内存空间，同时请求加载同一个资源也很浪费时间资源，占用带宽，影响页面性能。
        >
        > 如果把不同站点里的共同静态资源放在cdn，浏览器就只会缓存这个资源一次啦，因为不同站点加载的静态资源都在同一个站点里，如果浏览器缓存的还有效，也不用发起请求了。而且发起请求时也不用携带主页面的cookie等数据，减少了数据传输量。

  - [x] 优化后台逻辑代码，加快数据查询速度

- SSL

- initial connection

- DNS lookup

  dns域名解析后再dns服务器上会有一个TTL值(缓存存活时间)，如果再次访问的时间在这个时间内就不需要再次查询。TTL值一般设置为1天。

  dns服务器上会限制缓存数量，如果超过这个缓存数量，那么之前缓存的数据，无论TTL是否失效，都直接舍弃。

  浏览器一般也会缓存，如果浏览器缓存失效，才会到操作系统缓存中查找，如果操作系统也没有就会发送在一台远程服务器。

  如果TCP通信(即keep-alive)很愉快，没有要断开的打算，无论缓存是否失效，都不需要再次查询。

- stalled

- queueing

  同一域名下浏览器的并发请求数是有限制的，即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。不同的浏览器并发请求数不一样。

  ![](https://github.com/shaniawei/resource/blob/master/images/9.png)

  - [x] 使用cdn，减少请求等待时间
  - [x] 域分片，将静态资源放置在不同服务器上，减少请求等待时间





## **开发之前关于页面性能的规划**

- **css文件放在head标签内，js文件放在body标签底部(必选)**

  - js阻塞浏览器对body中的dom解析。*浏览器解析html文档是从上往下执行的。页面渲染完成前，如果在head中引入js文件会阻塞浏览器对body中的dom解析，导致页面延迟显示。*
  - js还会阻塞后面组件的加载。*浏览器请求加载解析js时会禁止组件并行加载。假设可以并行加载，如果后一个js文件(简称A)体积小于前一个js(简称B)体积，这两个js文件是依赖关系，A必须使用B里面定义的方法，这个时候A加载好了，B还没有的话就会报错了。*
  - 如果js放在head中，这个js文件会对dom进行一些操作(譬如点击)，可是这个时候dom还没有解析出来。这个时候就会报错，而且绑定的操作也会无效。
  - css文件放在head中，避免白屏或者无样式页面的闪烁。


-   **图片使用规划**

    - 适当使用雪碧图、图片地图、图片based、字体图标，减少http请求数
    - 移动端尽量使用不大于100kb的图片，缩短下载时间

-   **代码规范(必选)**

    - 开发时注重代码的复用，不论是html、css还是js
    - js逻辑尽量不要过于复杂
    - dom结构不要过于复杂，尽量简洁

-   **图片懒加载(可选)**

    图片懒加载在一些大型的网站应用的比较多(淘宝，京东等)

    `背景`

    > 浏览器从上至下解析html，碰到img标签就会发起请求。假设某网页有100张图片需要加载，浏览器就会发起100个图片请求。
    >
    > 假设两个用户先后访问这个页面，这个时候服务器正在处理那100个图片请求，没法处理另一个用户的页面请求，造成另一个用户的首屏出现延迟。
    >
    > 另一方面，假设这个页面底部还有js文件。这个js文件里有首屏dom的一些交互逻辑。当用户与页面首屏进行交互的时候可能会出现没有反应的情况，因为这个时候js还没加载完/请求还在等待中，前面还有一堆的图片请求。
    >
    > **由此看来，一次性加载太多图片会给服务器造成很大的压力，同时也很浪费服务器的资源(用户很有可能不会看下面的内容，直接在首屏操作跳转到起亚页面去了，这个时候也就没必要加载下面的图片了)**

    `解决方式`

    不给img标签添加src属性，将图片路径存储在data-XXX属性中。图片出现在可视窗口中就加载图片。具体实现[点击这里](https://www.cnblogs.com/xiaohuochai/p/4859899.html)

-   **使用缓存(可选)**

    - [x] expires
    - [x] cache-control
    - [x] etag
    - [x] 还有个什么？

    在第一次打开页面时缓存并没有起到任何作用，缓存仅在用户第一次访问了网页之后将一些资源缓存在本地，等下次用户访问这个网页的时候直接获取本地有效的资源，而不用发起http请求或者下载资源。

    其实即使没有配置这些字段，浏览器也会缓存资源的，但是？

    `缓存有些情况下并没有使网站加载时间获得任何收益：`

    - 用户并不是每天都打开一次该页面，而可能很久才会访问一次。间隔时间可能超过缓存资源的最大有效时间
    - 用户可能手动清楚浏览器缓存
    - 用户安装的一些杀毒软件可能会自动清楚浏览器缓存

-   **cdn(可选)**


- ……

  ​



## 开发后关于页面性能的优化

使用 [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights) 或者[这个工具](http://www.mmtrix.com/evaluate/applist#)可以确定应用到网站的性能最佳做法，以及使用 [PageSpeed 优化工具](https://developers.google.com/speed/pagespeed/optimization)将应用这些最佳做法的流程自动化。

根据监测出来的结果应用相对应的优化方案

## **页面运行速度过慢**

首先了解performance面板，之前叫时间线面板，该面板可分析网站的运行性能情况，根据分析结果寻找运行系能差的原因。可查看参考资料中的第五第六，里面说明很详细。[官网了解performance面板，需翻墙](https://developers.google.com/web/tools/chrome-devtools/#_7)

常见原因：DOM操作频繁，频繁触发回流，循环耗时等。当然，大多数小问题导致的问题在网站的整体效果上看可能会感知不到，而当你感觉到卡的时候肯定是“出事了”。

**注意点：**

- 尽量避免页面的重绘和重排
- js逻辑不要太过复杂(js操作出来的一些动画效果等)





参考资料：

1. [Google Chrome 中的高性能网络](https://www.igvita.com/posa/high-performance-networking-in-google-chrome/)讨论了 Chrome 网络内部机制，以及您如何充分利用它们让您的网站更快。
2. [gzip 压缩的工作原理](https://developers.google.com/speed/articles/gzip)提供了 gzip 压缩的高级概览，并介绍了这种压缩为什么是一种不错的方法。
3. [网页性能最佳做法](https://developers.google.com/speed/docs/best-practices/rules_intro)提供了更多用于优化您的网页或应用的网络性能的提示。
4. https://www.zhihu.com/question/27085552/answer/35194131
5. [什么？页面卡顿？操作慢？](https://juejin.im/entry/59a67ef06fb9a024903aba71)
6. https://zhuanlan.zhihu.com/p/29879682页面运行时的性能表现监测案例



